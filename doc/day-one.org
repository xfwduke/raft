#+TITLE: day one
#+AUTHOR: xfwduke

* 选举

** 基本概念

*** /state/

节点有 /3/ 种状态
1. ~Follower~
2. ~Candidate~
3. ~Leader~

节点刚启动时，总会处于 /Follower/ 状态。

*** /RPC/

理论上来说， /raft/ 只需要 /2/ 种 /RPC/

1. ~RequestVote RPC~ ：在选举阶段由 /Candidate/ 发起
2. ~AppendEntries RPC~ ：由 /Leader/ 发起，有 /2/ 个应用场景
  1. 复制日志条目
  2. 心跳维持，此时 /RPC Request/ 不包含日志条目信息

*** /timeout/

/raft/ 有 /2/ 个 /timeout/

1. ~heartbeat timeout~
2. ~election timeout~

两个 /timeout/ 的典型时长都是 /150~300ms/ 的随机值。

**** /heartbeat timeout/
由 /Leader/ 维持，周期性的向 /Follower/ 发送不带日志条目的 /AppendEntries Request/ 来重置 /Follower/ 的 /election timeout/，用于维持自身的领导地位。

**** /election timeout/
由 /Follower/ 维持，如果在超时时间内没有收到任何 /RPC Request/ ，会转变为 /Candidate/ 并发起选举。

*** ~term~
这个术语在中文的翻译中被翻译成 ~任期~ ，在论文中是这样描述的
#+BEGIN_QUOTE
Raft divides time into /terms/ of arbitray length, as shown in Figure ...

Each term begins with an election, in which one or more candidates attempt to become leader...

If a candidate wins the election, then it serves as leader for the rest of the term.
In some situations an election will result in a split vote. In this case the term will end with no leader; a new term whill begin shortly.
#+END_QUOTE

#+CAPTION: Raft divides time into terms
#+ATTR_HTML: :width 30% :height 30%
[[file:img/Screenshot%20from%202018-09-15%2022-29-57.png]]

图的说明里面由一句话比较关键
#+BEGIN_QUOTE
After a successful election, a single leader manages the cluster until then end of the term.
#+END_QUOTE

上面所有的文件加上图，充分解释了 ~term~ 这个关键概念。但就是这些文字和图，最开始看的时候引起来很大的误解，至少我是误解的一塌糊涂。

**** 任期切换
原文提到， /term/ 是 /raft/ 管理时间的单位，而其长度还是 _*任意*_ 的。这就很误导人了，最初还以为是类似操作系统 /CPU/ 时间片的概念，只是时长是随机的，实际根本不是这样。

这就需要搞清楚一件事情，既然 /raft/ 以 /term/ 作为单位来管理时间，那到底如何划分不同的 /term/。

实际上，只有发生 /election timeout/ 的时候，才会结束当前 /term/ ， 并开始一个新的 /term/ 。同时，由于发生了 /election timeout/ ，必然会发起一个选举流程( ~election~ )，所以才会如原文所说： /Each term begins with a election/ 。

**** 任期长度
原文还提到，/term/ 的长度是任意时长。在搞清楚任期切换后，这个 _*任意*_ 就没那么难以理解了。

1. 在完成一次成功的选举后，集群进入正常的日志复制状态，一直到必须进行一次新的选举
2. 如果选举失败，则过了一小段时间( /election timeout again/ )，又会发起一次新的选举

/term/ 的时长是第一次选举开始到第二次选举开始间的时长，所以说时长是任意的。


** 节点实现

*** 节点结构

节点的众多属性中和选举相关的倒是不多，只有 /2/ 个
1. ~currentTerm~ ： 当前任期号，初始值为 /0/ 并单调增加
2. ~votedFor~ ：当前任期收到的选票所代表的 /Candidate/ 的 /CandidateId/

所以节点可以定义为
#+BEGIN_SRC go
type Node struct {
	currentTerm uint64
	votedFor uint64
}
#+END_SRC

*** 节点状态

论文中并没有说节点结构必须包含自身状态，但实现的时候总是需要的，所以节点结构需要更新为
#+BEGIN_SRC go
type NodeState int

const (
	Follower NodeState = iota
	Candidate
	Leader
)

func (r NodeState) String() string {
	return [...]string{"Follower", "Candidate", "Leader"}[r]
}

type Node struct {
	currentTerm uint64
	votedFor    uint64
	nodeState NodeState
}
#+END_SRC

*** /election timeout/


